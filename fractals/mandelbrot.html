<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Mandelbrot Fractal Explorer</title>
    
    <link rel="stylesheet" href="CSS/style.css">

</head>
<body>

    <canvas id="canvas"></canvas>

    <button id="toggle-controls-btn" class="controls-toggle-btn">Show Controls</button>
    <a id="about-link" href="https://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank" rel="noopener noreferrer">About</a>
    
    <div id="controls-container" class="hidden">
        <div class="controls-header">
            <h1>Mandelbrot Explorer</h1>
            <button id="reset-btn">Reset</button>
        </div>

        <div class="control-group">
            <label for="iterations">Iterations: <span id="iterations-value">200</span></label>
            <input id="iterations" type="range" min="50" max="2000" value="200">
        </div>

        <div class="control-group">
            <label for="color-power">Color Power: <span id="color-power-value">0.5</span></label>
            <input id="color-power" type="range" min="0.1" max="2.0" value="0.5" step="0.05">
        </div>

        <div class="control-group">
             <label>Gradient Colors</label>
             <div class="color-grid">
                <input type="color" id="color1" value="#0d001a">
                <input type="color" id="color2" value="#331a80">
                <input type="color" id="color3" value="#e6e6ff">
                <input type="color" id="color4" value="#ffb300">
                <input type="color" id="color5" value="#00050d">
             </div>
        </div>
                
        <div class="stats-grid">
            <div>
                <span class="stat-label">Center X:</span>
                <span id="center-x-val" class="stat-value">0.0</span>
            </div>
             <div>
                <span class="stat-label">Center Y:</span>
                <span id="center-y-val" class="stat-value">0.0</span>
            </div>
            <div class="span-2">
                <span class="stat-label">Zoom Level:</span>
                <span id="zoom-val" class="stat-value">1.0</span>
            </div>
        </div>
    </div>

<script id="vertex-shader" type="x-shader/x-vertex">// This shader simply creates a canvas-filling rectangle.
// The real work happens in the fragment shader.
attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}</script>

<script id="fragment-shader" type="x-shader/x-fragment">precision highp float;

// Uniforms are variables passed from JavaScript to the shader
uniform vec2 u_resolution;
uniform vec2 u_center;
uniform float u_zoom;
uniform int u_max_iterations;
uniform float u_color_power;

// Colors for the gradient
uniform vec3 u_color1;
uniform vec3 u_color2;
uniform vec3 u_color3;
uniform vec3 u_color4;
uniform vec3 u_color5;

// This function converts a normalized value (0-1) to a color.
vec3 colorize(float t) {
    t = pow(t, u_color_power); // Use power to adjust color distribution
    
    if (t < 0.25) return mix(u_color1, u_color2, t / 0.25);
    if (t < 0.5) return mix(u_color2, u_color3, (t - 0.25) / 0.25);
    if (t < 0.75) return mix(u_color3, u_color4, (t - 0.5) / 0.25);
    return mix(u_color4, u_color5, (t - 0.75) / 0.25);
}

// The core Mandelbrot Set calculation
void main() {
    // 1. Map pixel coordinate to the complex plane
    vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution) / min(u_resolution.x, u_resolution.y);
    vec2 c = u_center + uv / u_zoom;
        
    vec2 z = vec2(0.0);
    int i = 0;

    // 2. The escape-time algorithm
    for (int j = 0; j < 2000; j++) { // Use a fixed loop limit for performance
        if (j >= u_max_iterations) break;
        // z = z^2 + c
        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
        if (dot(z, z) > 4.0) { // Check if |z|^2 > 2^2
            break;
        }
        i = j;
    }

    // 3. Color the pixel
    if (i >= u_max_iterations - 1) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // Inside the set (black)
    } else {
        // Smooth coloring algorithm (Normalized Iteration Count)
        float smoothed = float(i + 1) - log2(log2(dot(z, z))) / log2(2.0);
        float normalized = smoothed / float(u_max_iterations);
        gl_FragColor = vec4(colorize(normalized), 1.0);
    }
}</script>

<script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl', { antialias: true });

    // --- DOM Elements ---
    const controlsContainer = document.getElementById('controls-container');
    const toggleControlsBtn = document.getElementById('toggle-controls-btn');
    const iterationsSlider = document.getElementById('iterations');
    const iterationsValue = document.getElementById('iterations-value');
    const colorPowerSlider = document.getElementById('color-power');
    const colorPowerValue = document.getElementById('color-power-value');
    const colorPickers = [
        document.getElementById('color1'), document.getElementById('color2'),
        document.getElementById('color3'), document.getElementById('color4'),
        document.getElementById('color5')
    ];
    const resetBtn = document.getElementById('reset-btn');
    const centerXVal = document.getElementById('center-x-val');
    const centerYVal = document.getElementById('center-y-val');
    const zoomVal = document.getElementById('zoom-val');

    // --- WebGL Setup ---
    let shaderProgram;
    let positionBuffer;
    let positionAttributeLocation;

    // --- Fractal State ---
    const DEFAULTS = {
        center: [-0.5, 0.0],
        zoom: 1.0,
        maxIterations: 200,
        colorPower: 0.5,
        colors: ["#0d001a", "#331a80", "#e6e6ff", "#ffb300", "#00050d"]
    };
    let center = [...DEFAULTS.center];
    let zoom = DEFAULTS.zoom;
    let maxIterations = DEFAULTS.maxIterations;
    let colorPower = DEFAULTS.colorPower;
    let colors = [...DEFAULTS.colors];
    
    // --- Interaction State ---
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };
    
    // --- Helper Functions ---
    function hexToRgb(hex) {
        const r = parseInt(hex.slice(1, 3), 16) / 255;
        const g = parseInt(hex.slice(3, 5), 16) / 255;
        const b = parseInt(hex.slice(5, 7), 16) / 255;
        return [r, g, b];
    }

    function initWebGL() {
        const vertexShaderSource = document.getElementById('vertex-shader').text;
        const fragmentShaderSource = document.getElementById('fragment-shader').text;

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        shaderProgram = createProgram(gl, vertexShader, fragmentShader);
        positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
        
        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }

    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
        console.error('Error compiling shader:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
        console.error('Error linking program:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }

    function render() {
        const { clientWidth, clientHeight } = gl.canvas;
        if (gl.canvas.width !== clientWidth || gl.canvas.height !== clientHeight) {
            gl.canvas.width = clientWidth;
            gl.canvas.height = clientHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(shaderProgram);

        // Pass uniforms
        gl.uniform2f(gl.getUniformLocation(shaderProgram, 'u_resolution'), gl.canvas.width, gl.canvas.height);
        gl.uniform2f(gl.getUniformLocation(shaderProgram, 'u_center'), center[0], center[1]);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'u_zoom'), zoom);
        gl.uniform1i(gl.getUniformLocation(shaderProgram, 'u_max_iterations'), maxIterations);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'u_color_power'), colorPower);
        colors.forEach((hex, i) => {
            const rgb = hexToRgb(hex);
            gl.uniform3f(gl.getUniformLocation(shaderProgram, `u_color${i+1}`), rgb[0], rgb[1], rgb[2]);
        });
        
        // Bind position buffer and draw
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
                
        updateUI();
    }

    function updateUI() {
        centerXVal.textContent = center[0].toExponential(4);
        centerYVal.textContent = center[1].toExponential(4);
        zoomVal.textContent = zoom.toExponential(4);
        iterationsValue.textContent = maxIterations;
        colorPowerValue.textContent = parseFloat(colorPower).toFixed(2);
    }

    // --- Event Listeners ---
    function setupEventListeners() {
        // Zooming
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const minDim = Math.min(rect.width, rect.height);
            const mouseComplexX = center[0] + (mouseX * 2 - rect.width) / minDim / zoom;
            const mouseComplexY = center[1] + (rect.height - mouseY * 2) / minDim / zoom;
                        
            const zoomFactor = e.deltaY < 0 ? 1.4 : 1 / 1.4;
            zoom *= zoomFactor;
                        
            center[0] = mouseComplexX - (mouseComplexX - center[0]) / zoomFactor;
            center[1] = mouseComplexY - (mouseComplexY - center[1]) / zoomFactor;

            requestAnimationFrame(render);
        });

        // Panning
        canvas.addEventListener('mousedown', e => {
            isDragging = true;
            canvas.style.cursor = 'grabbing';
            lastMousePos = { x: e.clientX, y: e.clientY };
        });
        canvas.addEventListener('mousemove', e => {
            if (!isDragging) return;
            const dx = e.clientX - lastMousePos.x;
            const dy = e.clientY - lastMousePos.y;
            const minDim = Math.min(canvas.width, canvas.height);
            center[0] -= dx * 2 / minDim / zoom;
            center[1] += dy * 2 / minDim / zoom;
            lastMousePos = { x: e.clientX, y: e.clientY };
            requestAnimationFrame(render);
        });
        const stopDragging = () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        };
        canvas.addEventListener('mouseup', stopDragging);
        canvas.addEventListener('mouseleave', stopDragging);
        
        // --- UI Controls ---
        toggleControlsBtn.addEventListener('click', () => {
            const isHidden = controlsContainer.classList.toggle('hidden');
            toggleControlsBtn.textContent = isHidden ? 'Show Controls' : 'Hide Controls';
        });

        const requestRender = () => requestAnimationFrame(render);

        iterationsSlider.addEventListener('input', e => {
            maxIterations = parseInt(e.target.value);
            iterationsValue.textContent = maxIterations;
        });
        iterationsSlider.addEventListener('change', requestRender);
        
        colorPowerSlider.addEventListener('input', e => {
            colorPower = parseFloat(e.target.value);
            colorPowerValue.textContent = colorPower.toFixed(2);
        });
        colorPowerSlider.addEventListener('change', requestRender);

        colorPickers.forEach((picker, i) => {
            picker.addEventListener('input', e => {
                colors[i] = e.target.value;
                requestRender(); // Render on color change for immediate feedback
            });
        });

        resetBtn.addEventListener('click', () => {
            center = [...DEFAULTS.center];
            zoom = DEFAULTS.zoom;
            maxIterations = DEFAULTS.maxIterations;
            colorPower = DEFAULTS.colorPower;
            colors = [...DEFAULTS.colors];

            // Reset UI elements
            iterationsSlider.value = maxIterations;
            colorPowerSlider.value = colorPower;
            colorPickers.forEach((picker, i) => picker.value = colors[i]);
            
            requestAnimationFrame(render);
        });
                
        window.addEventListener('resize', requestRender);
    }

    // --- Main Execution ---
    initWebGL();
    setupEventListeners();
    requestAnimationFrame(render); // Initial render
</script>

</body>
</html>